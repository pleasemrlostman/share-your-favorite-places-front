# Package Manager

### 등장 배경

초창기 자바스크립트에서 특정 라이브러리에 대한 의존성을 설치하는 방식은 그저 `<srcript>`태그로 직접 로드하여 사용하는 방식이었다.

이러한 방식은 특정 라이브러리에 대한 의존성의 순서가 무조건 보장되어야 한다는 단점이 있었는데, 이를 보완하기 위해 나온 개념이 바로 package manager 인 것이다.

### 공통 기능

대부분의 패키지 매니저는 아래와 같은 기능을 공통적으로 수행한다. (물론 각각의 패키지 매니저에 따라 약간씩 차이가 있긴 하다.)

- 메타데이터 처리 및 쓰기
- 모든 의존성을 일괄(Batch) 설치 또는 업데이트
- 의존성 추가, 업데이트 및 제거
- 스크립트 실행
- 패키지 배포(publish)
- 보안 감사(audit) 수행

## npm

```
.
├── node_modules/
├── .npmrc
├── package-lock.json
└── package.json
```

### 특징

현존하는 모든 Node.js 패키지 매니저의 조상.

이전의 귀찮고 번거로운 의존성 설치를 획기적인 방식으로 최소화 시켜주었다.

우리가 지금도 npm을 설치하면 나타나는 package.json, node_modules 와 같은 파일로 관리하는 의존성 개념은 모두 npm에서 출발했다고 해도 과언이 아니다.

### 장점

- 의존성 관리

package.json 파일로 프로젝트 전반적인 의존성을 한번에 관리한다.

특정 라이브러리들이 어떤 환경에서 의존성을 주입받아야 하는지에 대한 설정도 할 수 있어 패키지 매니저 이전의 방식에 비해 획기적인 개발 시간 단축이 이뤄졌다.

- 버전 관리와 호환성 유지

시맨틱 버저닝 규칙을 도입하여, 특정 패키지나 라이브러리의 버전을 효율적으로 관리할 수 있도록 해준다.

- 가장 큰 라이브러리 도서관.

npm은 현존하는 패키지 매니저 중 가장 큰 소프트웨어 레지스트리 저장소로 활용되고 있다.

다른 패키지 매니저가 지원하지 않는 여러 라이브러리들은 개발자에게 npm을 선택할 수 밖에 없는 이유가 되기도 한다.

### 단점

- 대규모 의존성 문제

프로젝트에 너무 많은 의존성을 주입하게 된다면, 해당 의존성끼리 같은 의존성에 대한 다른 버전을 요구하는 일들이 일어나게 된다.

아래와 같은 경우라 할 수 있겠다.

```
1. packageA는 packageC v1.0을 필요로 합니다.
2. packageB는 packageC v2.0을 필요로 합니다.

하지만, packageC의 두 버전이 서로 호환되지 않을 경우 충돌이 발생하게 됩니다.

또한 packageA 를 설치했지만 packageA 가 다른 패키지에 의존하게 된다면 관련된 의존성 패키지들을 모두 설치하게 됩니다.
```

결국 이러한 이슈로 인해 빌드가 실패하거나 런타임 에러가 발생하는 일도 종종 일어날 수 있다.

- 성능 저하

인간이 만든 가장 큰 복합체로 기네스북에 등재될 만큼 node_modules 폴더는 엄청나게 방대한 소스를 가지고 있다.

이러한 폴더는 설치 과정에서 가장 많은 시간을 잡아먹는 요소로 맹활약하는데, npm은 의존성 트리가 크고 복잡한 구조일 경우 나쁜 의미로 Cherry on a Cake으로 작용하게 된다.

또한 직렬 처리 방식으로 인하여 패키지 설치 시간이 선형적으로 증가한다는 문제 또한 성능에 지대한 영향을 미치는 요소로 작용한다.

- 버전 관리

시맨틱 버저닝을 사용하면서 패키지 버전을 효율적으로 관리할 수 있다는 장점도 있지만, 해당 버전의 업데이트를 어떤식으로 해석하는가에 따른 개개인의 인식에 의한 문제가 발생할 수 있다.

예를 들면 아래와 같은 시맨틱 멘트에 대한 가이드가 있다고 가정하자.

```
- MAJOR: 호환되지 않는 API 변경이 있을 때
- MINOR: 호환 가능한 새로운 기능이 추가될 때
- PATCH: 호환 가능한 버그 수정이 있을 때
```

이런 경우에, 특정 패키지 개발자는 해당 패치 버전을 minor라 생각할 수도 있지만, 다른 개발자들은 이 버전을 major라 생각할 수 있기 떄문에 기존의 기능과 충돌하는 호환성 문제를 일으켰다.

## pnpm

```
.
├── node_modules/
│   └── .pnpm/
├── .npmrc
├── package.json
└── pnpm-lock.yml
```

### 특징

Yarn이 나오고 난 뒤, 기존의 패키지 매니저가 가지고 있던 모든 문제가 해결된건 아니었다. Yarn v1이 가지고 있던 가장 큰 문제중 하나인 중복된 의존성 파일 설치였다(npm과 같은 의존성 개념. 물론 속도는 더 빨랐다.)

이를 해결하기 위해 2017년에 pnpm이 등장했다. pnpm은 yarn과 npm 가지고 있던 중복 의존성(유령 의존성) 문제에 대하여 '내용 주소화 저장소' 전략을 택했다.

pnpm은 이러한 유령 의존성 문제를 Symlinked 구조로 해결하였다.

```
Project/
├── node_modules/
│ ├── .pnpm/
│ │ ├── package-C@1.0/
│ │ └── package-D@1.0/
│ ├── package-A/
│ │ └── node_modules/
│ │ └── package-C@1.0 -> ../../.pnpm/package-C@1.0/
│ ├── package-B/
│ │ └── node_modules/
│ │ └── package-D@1.0 -> ../../.pnpm/package-D@1.0/
└── package.json
```

위 코드에서 보이는 것과 같이, 특정 심볼릭 링크를 통해 특정 라이브러리는 자신에 종속된 파일들만 접근할 수 있도록 설정하였다.

### 장점

- 향상된 저장 공간 관리

pnpm이 만들어진 이유 중 하나인 패키지 의존성 문제를 해결하면서 자연스레 동일한 패키지를 중복하여 저장하지 않는 문제 또한 사라졌다. 이는 곧 저장소 공간 활용에서 큰 이점을 보이며, 나아가 빌드 타임 단축도 이뤄낼 수 있다.

- 빠른 설치 속도

패키지 병렬처리 및 중복된 패키지 다운로드 방지라는 큰 이점 두개를 통해 여타 패키지 매니저보다 빠른 패키지 다운로드 속도를 자랑한다.

- 편의성

기존의 npm에서 파생된 패키지 매니저 답게 기존 npm 생태계에 아주 알맞게 설정되어 있기 때문에, npm 을 사용하는 유저 입장에서 pnpm으로 마이그레이션이 비교적 쉽다.

### 단점

- 호환성

npm의 다음세대라 할 수 있는 pnpm은 npm과 같은 환경에서 사용할 수 있지만, 모든 환경에 대한 호환성을 지원한다고 할 수는 없다.

일부 node modules 의존성이 매우 복잡한 경우에는, 이러한 pnpm의 심링크 형식이 제대로 동작하지 않을 가능성도 존재한다. pnpm이 해당 폴더 구조를 이해하고 예상하는 도구의 한계라 하겠다.

- 빈약한 커뮤니티

당연히 최근에 나온 패키지 매니저이기 떄문에 상대적으로 이슈가 생겼을 때 도움을 받을 수 있는 커뮤니티의 숫자나 질적인 차이가 난다.

특히나 특정 라이브러리는 pnpm을 지원하지 않을 수 있기 때문에, 어쩔 수 없이 다른 패키지 매니저를 사용해야 하는 경우가 생길 수 있다.

## Yarn v1 (Yarn classic)

```
.
├── .yarn/
│   ├── cache/`
│   └── releases/
│       └── yarn-1.22.17.cjs
├── node_modules/
├── .yarnrc
├── package.json
└── yarn.lock
```

### 특징

2016년에 npm 이 가지고 있던 의존성에 대한 일관성 그리고 보아니 및 성능 문제와 관련된 이슈를 해결하기 위해 페이스북, goole과 같은 거대 일류 양자로켓 기업들이 만든 패키지 매니저. 이름에서 부터 Yet Another Resource Negotiator.

물론, npm 의 기조를 대부분 따라가긴 했지만, 기존의 npm이 가지고 있던 의존성 설치 시간을 낮추기 위해 병렬적으로 설치하는 방식을 채택했다.

그 이외에도 DX와 보안 성능을 높이기 위해 아래와 같은 새로운 개념들도 만들어냈다.

- 네이티브 모노레포 지원
- 캐시-인식 설치
- 오프라인 캐싱
- Lock 파일

### 장점

- 빠른 성능

npm은 의존성 설치를 여러개 할 시, 직렬적으로(또는 순차적으로) 설치하기 때문에 설치 시간이 오래걸린다는 단점이 있었다.

이러한 단점을 극복하기 위해 Yarn에서는 패키지를 병렬처리하여 설치 속도를 향상시켰다.

또한 한번 다운로드한 패키지를 캐싱하여 재 설치시 좀 더 효율적으로 다운로드 할 수 있도록 하였다.

- 괜찮아진 보안성

        npm의 초기 버전은 패키지 무결성(변조되거나 손상되지 않았음을 보증하는 방식)이나 체크섬(패키지 무결성을 보장하기 위해 사용되는 일종의 해시 값)이 제한되었습니다.

        Yarn(v1)은 모든 패키지의 체크섬을 계산하고 이를 검증하는 과정을 통해 패키지 무결성을 강화하여 보안 문제를 방지하였습니다.

- 그나마 나아진 의존성 관리

지금은 npm도 도입한 기능이지만, 그 당시 npm에는 설치한 패키지의 의존성 관게와 버전이 명확하게 관리되지 않았다.

이를 해결하기 위해서 Yarn에서는 Yarn.lock 파일을 도입하여 현재 프로젝트에 설치된 모든 패키지의 정확한 버전 정보를 기록, 관리하여 모든 환경에서 동일한 의존성을 확보할 수 있도록 하였다.

### 단점

- 유령 의존성 문제

npm의 진화 형태라고 해도, 여전히 중첩된 의존성 구조로 인한 중복 패키지 설치는 해결되지 않았다.

```
my-project/
├── node_modules/
│   ├── package-A/
│   │   ├── node_modules/
│   │   │   └── package-C@1.0.0/
│   │   └── package.json
│   ├── package-B/
│   │   ├── node_modules/
│   │   │   └── package-C@2.0.0/
│   │   └── package.json
│   └── package-C@1.5.0/
└── package.json
```

위와 같은 구조에서 결론적으로 package-c가 무려 3번이나 설치되는 치명적인 문제가 생겼으며, npm에서 말했던 문제 처럼 여러 중복된 의존성이 각기 다른 버전을 사용하고 있을 경우, 결국 npm과 동일한 문제를 일으켰다.

## Yarn v2 (Yarn Berry)

```
.
├── .yarn/
│   ├── cache/
│   ├── releases/
│   │   └── yarn-3.1.1.cjs
│   ├── sdk/
│   └── unplugged/
├── .pnp.cjs
├── .pnp.loader.mjs
├── .yarnrc.yml
├── package.json
└── yarn.lock
```

### 특징

이전 버전에서 해결하지 못했던 유령 의존성 문제를 해결하기 위해 나온 v2. 이러한 문제의 해결 방안으로 PnP 방식을 도입하였다.

특이한 점으로는 따로 node_modules를 생성하지 않고 cache 폴더에 압축 파일 형태로 저장하여 관리한다.

이러한 관리 형태는 pnp.cjs 라는 파일에 정확한 위치를 기록하기 때문에 특정 패키지는 자신의 의존성 패키지 외에는 접근할 수 없기 때문에 이를 통해 의존성 문제를 해결할 수 있었다.

Zero-install 이라는 방법을 사용하는데, 이는 모든 패키지가 압축된 파일 형태로 존재하기 떄문에 따로 의존성을 설치하는 과정을 거치지 않고 그대로 사용할 수 있다. 그렇기 때문에 배포 시간도 단축시킬수 있다.

### 장점

- 뛰어난 저장 공간 관리

PnP 방식을 사용하기 떄문에 따로 node_modules 폴더를 생성하지 않고, 직접 패키지 파일을 연결하는 방식이기 때문에 중복 생성도 하지 않고, 압축된 파일은 저장 공간을 효율적으로 사용할 수 있게 되는 장점을 제공해준다.

- 더 빠른 설치 속도와 안정성

패키지를 동시에 다운로드하는 병렬 처리 방식을 pnpm과 같이 동일하게 사용한다.

### 단점

- 호환성 문제

어이가 없지만, 만약 특정 프로젝트 패키지 중 단 하나라도 PnP 방식을 지원하지 않는다면 node_modules 폴더를 생성해버린다.

- Zero install 문제

node_modules 폴더가 없다는건 용량적인 측면에서 이점이 될 수 있지만, 이는 작은 규모일 경우이다. 대규모 프로젝트로 갈 수록 cache 폴더의 크기는 커질것이고, 이 모든 양의 데이터는 git 저장소에 포함되는 방식이기 때문에 commit push checkout 동작이 느려질 수 있다.
